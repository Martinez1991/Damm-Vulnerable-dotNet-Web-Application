"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lintSource = void 0;
const SecretLintSourceCodeImpl_1 = require("./SecretLintSourceCodeImpl");
const RuleContext_1 = require("./RuleContext");
const RunningEvents_1 = require("./RunningEvents");
const profiler_1 = require("@secretlint/profiler");
const RulePresetContext_1 = require("./RulePresetContext");
const messages_1 = require("./messages");
const debug = require("debug")("@secretlint/core");
const lintSource = ({ source, options }) => {
    var _a;
    profiler_1.secretLintProfiler.mark({
        type: "@core>lint::start",
        id: source.filePath,
    });
    debug(`source filePath: %O`, source.filePath);
    debug(`options: %O`, options);
    const rules = options.config.rules;
    const locale = (_a = options.locale) !== null && _a !== void 0 ? _a : "en";
    const contextEvents = RuleContext_1.createContextEvents();
    const runningEvents = RunningEvents_1.createRunningEvents();
    const reportedMessages = [];
    const ignoredMessages = [];
    // setup
    contextEvents.onReport((message) => {
        reportedMessages.push(message);
    });
    contextEvents.onIgnore((message) => {
        ignoredMessages.push(message);
    });
    // Create a SourceCode for linting
    const sourceCode = new SecretLintSourceCodeImpl_1.SecretLintSourceCodeImpl({
        content: source.content,
        filePath: source.filePath,
        ext: source.ext || "",
        contentType: source.contentType,
    });
    profiler_1.secretLintProfiler.mark({
        type: "@core>setup-rules::start",
    });
    rules.forEach((rule) => {
        profiler_1.secretLintProfiler.mark({
            type: "@core>setup-rule::start",
            id: rule.rule.meta.id,
        });
        registerRule({
            sourceCode,
            config: options.config,
            descriptorRule: rule,
            contextEvents,
            runningEvents,
            locale,
        });
        profiler_1.secretLintProfiler.mark({
            type: "@core>setup-rule::end",
            id: rule.rule.meta.id,
        });
    });
    profiler_1.secretLintProfiler.mark({
        type: "@core>setup-rules::end",
    });
    // start to run
    return runningEvents
        .runLint({
        sourceCode,
    })
        .then(() => {
        return {
            filePath: source.filePath,
            messages: messages_1.cleanupMessages({
                reportedMessages,
                ignoredMessages,
                allowMessageIds: runningEvents.collectAllowMessageIds(),
            }),
        };
    })
        .finally(() => {
        profiler_1.secretLintProfiler.mark({
            type: "@core>lint::end",
            id: source.filePath,
        });
    });
};
exports.lintSource = lintSource;
const isRulePreset = (ruleDescriptor) => {
    return ruleDescriptor.rule.meta.type === "preset";
};
const isRule = (ruleDescriptor) => {
    return ruleDescriptor.rule.meta.type === "scanner";
};
/**
 * Rule Processing
 */
const registerRule = ({ sourceCode, config, descriptorRule, contextEvents, runningEvents, locale, }) => {
    var _a;
    const ruleId = descriptorRule.id;
    // Do not register disabled rule
    if (descriptorRule.disabled) {
        debug("Skip registerRule %s, because it is disabled", ruleId);
        return;
    }
    debug("registerRule %s", ruleId);
    // sharedOptions is {} by default
    // sharedOptions is shared between presets and rules
    const sharedOptionsWithDefault = (_a = config.sharedOptions) !== null && _a !== void 0 ? _a : {};
    // If option is not defined Options is {} by default
    if (isRulePreset(descriptorRule)) {
        const context = RulePresetContext_1.createRulePresetContext({
            descriptorRulePreset: descriptorRule,
            sourceCode,
            contextEvents: contextEvents,
            runningEvents: runningEvents,
            sharedOptions: sharedOptionsWithDefault,
            locale: locale,
        });
        runningEvents.registerRulePreset({
            descriptorRulePreset: descriptorRule,
            context,
        });
        return;
    }
    else if (isRule(descriptorRule)) {
        const context = RuleContext_1.createRuleContext({
            ruleId: ruleId,
            severity: descriptorRule.severity,
            meta: descriptorRule.rule.meta,
            sourceCode,
            contextEvents: contextEvents,
            sharedOptions: sharedOptionsWithDefault,
            locale: locale,
        });
        runningEvents.registerRule({
            descriptorRule: descriptorRule,
            context,
        });
        return;
    }
    throw new Error(`Unknown descriptor type: ${descriptorRule}`);
};
//# sourceMappingURL=index.js.map