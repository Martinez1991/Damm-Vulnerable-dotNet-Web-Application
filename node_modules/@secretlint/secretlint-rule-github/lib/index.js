"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.creator = exports.messages = void 0;
const regexp_string_matcher_1 = require("@textlint/regexp-string-matcher");
exports.messages = {
    GITHUB_TOKEN: {
        en: (props) => `found GitHub Token(${props.typeName}): ${props.KEY}`,
        ja: (props) => `GitHub Token(${props.typeName})が見つかりました： ${props.KEY}`,
    },
};
// ghp for GitHub personal access tokens
// gho for OAuth access tokens
// ghu for GitHub user-to-server tokens
// ghs for GitHub server-to-server tokens
// ghr for refresh tokens
const typeMap = new Map([
    ["ghp", "GitHub personal access tokens"],
    ["gho", "OAuth access tokens"],
    ["gho", "GitHub user-to-server tokens"],
    ["ghs", "GitHub user-to-server tokens"],
    ["ghr", "refresh tokens"],
]);
// FIXME: GitHub Token implement CRC-32 checksum
// We need to check it
// https://github.blog/2021-04-05-behind-githubs-new-authentication-token-formats/
const validChecksum = (_token) => {
    return true;
};
function reportIfFoundKey({ source, options, context, t, }) {
    var _a;
    // https://github.blog/2021-04-05-behind-githubs-new-authentication-token-formats/
    const GITHUB_TOKEN_PATTERN = /(?<type>ghp|gho|ghu|ghs|ghr)_[A-Za-z0-9_]{31,255}/g;
    const results = source.content.matchAll(GITHUB_TOKEN_PATTERN);
    for (const result of results) {
        const index = result.index || 0;
        const type = (_a = result.groups) === null || _a === void 0 ? void 0 : _a.type;
        const typeName = typeMap.get(type);
        if (!typeName) {
            throw new Error("Unknown type:" + typeName);
        }
        const match = result[0] || "";
        if (!validChecksum(match)) {
            continue;
        }
        const range = [index, index + match.length];
        const allowedResults = regexp_string_matcher_1.matchPatterns(match, options.allows);
        if (allowedResults.length > 0) {
            continue;
        }
        context.report({
            message: t("GITHUB_TOKEN", {
                KEY: match,
                typeName,
            }),
            range,
        });
    }
}
exports.creator = {
    messages: exports.messages,
    meta: {
        id: "@secretlint/secretlint-rule-github",
        recommended: true,
        type: "scanner",
        supportedContentTypes: ["text"],
        docs: {
            url: "https://github.com/secretlint/secretlint/blob/master/packages/%40secretlint/secretlint-rule-github/README.md",
        },
    },
    create(context, options) {
        const t = context.createTranslator(exports.messages);
        const normalizedOptions = {
            allows: options.allows || [],
        };
        return {
            file(source) {
                reportIfFoundKey({ source, options: normalizedOptions, context, t });
            },
        };
    },
};
exports.default = exports.creator;
//# sourceMappingURL=index.js.map