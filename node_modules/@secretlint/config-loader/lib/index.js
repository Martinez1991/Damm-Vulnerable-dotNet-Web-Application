"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadRawConfig = exports.loadConfig = exports.loadPackagesFromRawConfig = void 0;
const rc_config_loader_1 = require("rc-config-loader");
const profiler_1 = require("@secretlint/profiler");
const SecretLintModuleResolver_1 = require("./SecretLintModuleResolver");
const module_interop_1 = require("@textlint/module-interop");
const config_validator_1 = require("@secretlint/config-validator");
/**
 * Load packages in RawConfig and return loaded config object
 * @param options
 */
const loadPackagesFromRawConfig = (options) => {
    // Early validation, validate rawConfig by JSON Schema
    const resultValidateRawConfig = config_validator_1.validateRawConfig(options.rawConfig);
    if (!resultValidateRawConfig.ok) {
        return {
            ok: false,
            errors: [resultValidateRawConfig.error],
        };
    }
    profiler_1.secretLintProfiler.mark({
        type: "@config-loader>resolve-modules::start",
    });
    // Search secretlint's module
    const moduleResolver = new SecretLintModuleResolver_1.SecretLintModuleResolver({
        baseDirectory: options.node_moduleDir,
    });
    const errors = [];
    const rules = [];
    options.rawConfig.rules.forEach((configDescriptorRule) => {
        try {
            profiler_1.secretLintProfiler.mark({
                type: "@config-loader>resolve-module::start",
                id: configDescriptorRule.id,
            });
            const replacedDefinition = options.testReplaceDefinitions &&
                options.testReplaceDefinitions.find(({ id }) => {
                    return id === configDescriptorRule.id;
                });
            // TODO: any to be remove
            const ruleModule = replacedDefinition
                ? replacedDefinition.rule
                : module_interop_1.moduleInterop(require(moduleResolver.resolveRulePackageName(configDescriptorRule.id)));
            const secretLintConfigDescriptorRules = "rules" in configDescriptorRule && Array.isArray(configDescriptorRule.rules)
                ? configDescriptorRule.rules.filter((rule) => rule !== undefined)
                : undefined;
            rules.push({
                id: configDescriptorRule.id,
                rule: ruleModule,
                rules: secretLintConfigDescriptorRules,
                options: configDescriptorRule.options,
                severity: "severity" in configDescriptorRule ? configDescriptorRule.severity : undefined,
                disabled: configDescriptorRule.disabled,
                allowMessageIds: "allowMessageIds" in configDescriptorRule ? configDescriptorRule.allowMessageIds : undefined,
            });
            profiler_1.secretLintProfiler.mark({
                type: "@config-loader>resolve-module::end",
                id: configDescriptorRule.id,
            });
        }
        catch (error) {
            errors.push(error);
        }
    });
    profiler_1.secretLintProfiler.mark({
        type: "@config-loader>resolve-modules::end",
    });
    if (errors.length > 0) {
        return {
            ok: false,
            errors,
        };
    }
    const loadedConfig = {
        sharedOptions: options.rawConfig.sharedOptions,
        rules,
    };
    // Finally, validate loadedConfig with validator
    // This validator require actual `rule` creator for `disabledMessage` option.
    const resultValidateConfig = config_validator_1.validateConfig(loadedConfig);
    if (!resultValidateConfig.ok) {
        return {
            ok: false,
            errors: [resultValidateConfig.error],
        };
    }
    return {
        ok: true,
        config: loadedConfig,
    };
};
exports.loadPackagesFromRawConfig = loadPackagesFromRawConfig;
/**
 *  Load config file and return config object that is loaded rule instance.
 * @param options
 */
const loadConfig = (options) => {
    profiler_1.secretLintProfiler.mark({
        type: "@config-loader>load-config-file::start",
    });
    const rawResult = exports.loadRawConfig(options);
    profiler_1.secretLintProfiler.mark({
        type: "@config-loader>load-config-file::end",
    });
    if (!rawResult.ok) {
        return {
            ok: false,
            errors: rawResult.errors,
        };
    }
    profiler_1.secretLintProfiler.mark({
        type: "@config-loader>load-packages::start",
    });
    const result = exports.loadPackagesFromRawConfig({
        rawConfig: rawResult.rawConfig,
        node_moduleDir: options.node_moduleDir,
        testReplaceDefinitions: options.testReplaceDefinitions,
    });
    profiler_1.secretLintProfiler.mark({
        type: "@config-loader>load-packages::end",
    });
    if (!result.ok) {
        return {
            ok: false,
            configFilePath: rawResult.configFilePath,
            errors: result.errors,
        };
    }
    return {
        ok: true,
        config: result.config,
        configFilePath: rawResult.configFilePath,
    };
};
exports.loadConfig = loadConfig;
/**
 *  Load config file and return config object that is not loaded rule instance
 *  It is just JSON present for config file. Raw data
 * @param options
 */
const loadRawConfig = (options) => {
    try {
        const results = rc_config_loader_1.rcFile("secretlint", {
            cwd: options.cwd,
            configFileName: options.configFilePath,
            packageJSON: {
                fieldName: "secretlint",
            },
        });
        // Not Found
        if (!results) {
            return {
                ok: false,
                errors: [
                    new Error(`secretlint config is not found
                
Secrelint require .secretlintrc config file.
The config file define the use of rules.`),
                ],
            };
        }
        return {
            ok: true,
            rawConfig: results.config,
            configFilePath: results.filePath,
        };
    }
    catch (error) {
        return {
            ok: false,
            errors: [error],
        };
    }
};
exports.loadRawConfig = loadRawConfig;
//# sourceMappingURL=index.js.map