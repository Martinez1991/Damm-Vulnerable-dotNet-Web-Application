"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSecretLint = void 0;
const fs_1 = __importDefault(require("fs"));
const node_1 = require("@secretlint/node");
const search_1 = require("./search");
const runSecretLint = ({ cliOptions, engineOptions, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { ok, items } = yield search_1.searchFiles(cliOptions.filePathOrGlobList, {
        cwd: cliOptions.cwd,
        ignoreFilePath: cliOptions.ignoreFilePath,
    });
    if (!ok) {
        throw new Error("Not found target files");
    }
    const engine = yield node_1.createEngine(engineOptions);
    return engine
        .executeOnFiles({
        filePathList: items,
    })
        .then(({ ok, output }) => {
        // TODO: if has error, this should be stderr
        const outputFilePath = cliOptions.outputFilePath;
        if (outputFilePath !== undefined) {
            fs_1.default.writeFileSync(outputFilePath, output, "utf-8");
            // Return empty to console
            return {
                exitStatus: ok ? 0 : 1,
                stdout: null,
                stderr: null,
            };
        }
        return {
            exitStatus: ok ? 0 : 1,
            stdout: output,
            stderr: null,
        };
    })
        .catch((error) => {
        return {
            exitStatus: 1,
            stdout: null,
            stderr: error,
        };
    });
});
exports.runSecretLint = runSecretLint;
//# sourceMappingURL=index.js.map